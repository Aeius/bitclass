# spring framework 4.X
## file I/O - upload & download
### dependency 추가
```xml
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.5</version>
</dependency>
```
### File Resolver 등록
#### servlet-context.xml
property 필수사항은 maxUploadSize 하나뿐 value는 바이트 기준 직접 계산해서 넣어줘야함   
```xml
<!-- File Resolver -->
<beans:bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
  <beans:property name="maxUploadSize" value="5242880"/>
  <beans:property name="defaultEncoding" value="utf-8"/>
</beans:bean>
```
## Upload
### form 태그 작성
``` jsp
<form action="upload" method="post" enctype="multipart/form-data">
	<div>
		<input type="text" name="msg"/>
	</div>
	<div>
		<input type="file" name="file1"/>
	</div>
	<div>
		<button>업로드</button>
	</div>
</form>
```
### Controller
``` java
// path는 원래 OS기준으로 특정한 장소를 결정하여 저장을 해야한다!
String path = "E:\\webspace\\sts08\\up\\";

@ResponseBody
@PostMapping("/upload")
public void upload(MultipartFile file1, HttpServletRequest req) {
  // 파일명의 중복을 막기 위해 시간 추가
  String msg = System.currentTimeMillis() +"_";
  File f = new File(path + msg + file1.getOriginalFilename());	
//		   try(
//		    InputStream is = file1.getInputStream();
//		    OutputStream os = new FileOutputStream(f);
//		   ) {
//		    int su = -1;
//		    while((su=is.read())!=-1) {
//		      os.write(su);
//		    }
//		  } catch (IOException e) {
//		    e.printStackTrace();
//		  }
  // 위와 같은 IO 작업을 Spring에서 한줄로 처리 할 수 있다.
  file1.transferTo(f);
}
```
## Download
### View 작성
``` jsp
<h1>download</h1>
<p> file1: <a href="load?fname=${fname }">download</a></p>
<p> file2: <a href="load/${fname }">download</a></p>
```
### Controller
``` java
@GetMapping("/down")
public void down(Model model, String fname) {
  model.addAttribute("fname", fname);
}
  
// RequestParam을 이용한 다운로드
@GetMapping("/load")
public void load(String fname, HttpServletResponse resp) throws FileNotFoundException, IOException {
  File f = new File(path+fname);
  // 파일을 무조건 다운로드 되도록
  resp.setContentType("application/octet-stream");
  // 다운로드 되는 파일명 지정 (앞에 '_' 기준으로 시간이 달려있기 때문에 분리)
  resp.setHeader("Content-Disposition", "attachment; filename="+fname.split("_")[1]);
  try(InputStream is = new FileInputStream(f);
    OutputStream os = resp.getOutputStream();){
    int su = -1;
    while((su=is.read())!= -1) {
      os.write(su);
    }
  }
}

// PathVariable을 이용한 다운로드
// PathVariable에서 확장자까지 가져올려고하면 아래처럼 작성해야한다.
@GetMapping("/load/{fname:.+}")
public void load2(@PathVariable String fname, HttpServletResponse resp) throws FileNotFoundException, IOException {
  File f = new File(path+fname);
  // 파일을 무조건 다운로드 되도록
  resp.setContentType("application/octet-stream");
  // 다운로드 되는 파일명 지정 (앞에 '_' 기준으로 시간이 달려있기 때문에 분리)
  resp.setHeader("Content-Disposition", "attachment; filename="+fname.split("_")[1]);
  try(InputStream is = new FileInputStream(f);
    OutputStream os = resp.getOutputStream();){
    int su = -1;
    while((su=is.read())!= -1) {
      os.write(su);
    }
  }
}
```








