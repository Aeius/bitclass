## 23.01.11

## DB-mysql

## 제약조건

## join
### oracle 표준 방식
equal join
self join
오라클 표준방식은 결국 집합의 모든 형태를 나타내기 어렵고   
어떤 join방식인지 한눈에 알아보기 어렵기 때문에 ansi 방식이 새로 생겨나게 되었고   
이후 RDBMS들은 이 방식을 따라가게 되었음   

### ansi 방식
#### cross join
```
select * from emp cross join dept;
```
#### inner join(=equal join) where 대신에 on 사용하기 때문에 where로 조건을 더 달 수 있음
```
select * from emp inner join dept on emp.deptno=dept.deptno;
select * from emp inner join dept using(deptno); // 중복된 컬럼명이 있을 때
select * from emp natural join dept; // 오직 하나의 컬럼명만 중복되었을 때
select * from emp inner join dept on emp.deptno=dept.deptno where emp.deptno=10;
```
#### outer join
```
select * from emp left outer join dept on emp.deptno=dept.deptno;
select * from emp right outer join dept on emp.deptno=dept.deptno;

// 공통되지 않는 부분만
select * from emp left outer join dept using(deptno) where emp.empno is null;
select * from emp right outer join dept using(deptno) where emp.empno is null;
```
#### self join
```
select a.empno, a.ename, b.ename from emp a inner join emp b on a.mgr=b.empno;
```

### 변수 사용
```
set @su1:1234;
select @su1 from dual;
select @su2:=4321 from dual;

// rownum 만들어주기
set @rownum:=0;
select @rownum:=@rownum+1, empno, ename from emp;
select @rn:=@rn+1, empno, ename from emp, (select @rn:=0 from dual) a;
```

### 서브쿼리
```
// table 서브쿼리
select * from (select empno, ename from emp) a;

// column 서브쿼리
// return 값은 반드시 하나여야함 Error : Subquery returns more than 1 row
// 그렇기 때문에 보통 하나의 결과만을 리턴하는 그룹함수를 사용한다.
select empno, ename, sal,(select avg(sal) from emp) from emp;

// 조건절 서브쿼리
// 상황에 따라 다르다.
select empno, ename, sal from emp where sal<(select avg(sal) from emp);
select empno, ename, sal from emp where sal in (select sal from emp);

//기존값 복사 결과의 필드(컬럼,레코드) 복사
insert into dept (select * from dept where deptno=10);
// 테이블 복사
create table t50 as (select empno, ename from emp);
// 스키마만 복사
create table t51 as (select empno, ename from emp where 1!=1);
// 테이블 중복제거
create table dept2 as (select distinct deptno, dname, loc from dept);
drop table dept;
alter table dept2 rename dept;

// insert에 활용 단 이 쿼리는 레이스컨디션 문제가 발생할 수 도 있다. 걍 auto_increment쓰는게 낫다. 혹은 sequence 만들어 사용
insert into dept values ((select max(deptno)+1 from dept a), 'test', 'test');
```
