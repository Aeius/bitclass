# 암호화 encryption
### 암호화 인증 모듈을 쉽게쓰기 위한 코덱 의존성 추가   
``` xml
<!-- https://mvnrepository.com/artifact/commons-codec/commons-codec -->
<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
</dependency>
```
## Spring Security crpto 사용을 위한 의존성 추가
``` xml
<!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-crypto -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-crypto</artifactId>
    <version>6.0.2</version>
</dependency>
```
### SevletConfig
``` java
package com.bit.boot09.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

@Configuration
@EnableWebMvc
public class ServletConfig extends WebMvcConfigurerAdapter{
	@Bean
	PasswordEncoder getBCryptPasswordEncoder() {
		return new BCryptPasswordEncoder();
	}
}
```
### CryptService
``` java
package com.bit.boot09.service;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.digest.DigestUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class CryptService {
	
	final PasswordEncoder passwordEncoder;
	
//	@Value("${secure.key}")
	String key="oingisprettyintheworld1234567890";
    private String iv = "0123456789abcdef"; // 16byte

	// 암호화
	// 단방향 - 복호화(decoding) 불가능 - 패스워드 => MD5 SHA256
	public String createMd5Encrypt(String msg) {
		return DigestUtils.md5Hex(msg);
	}
	public String createSha256Encrypt(String msg) {
		return DigestUtils.sha256Hex(msg);
	}
	public String createSha512Encrypt(String msg) {
		return DigestUtils.sha3_512Hex(msg);
	}
	
	// 양방향 - 복호화 가능 단, 키를 이용해 인증해야만 가능 =>
	SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), "AES");
	public String createAESEncrypt(String msg) throws Exception {
		Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
	     c.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(iv.getBytes()));
	     byte[] encrypted = c.doFinal(msg.getBytes("UTF-8"));
	     String enStr = new String(Base64.encodeBase64(encrypted));
	     return enStr;
	}
	public String createAESDecrypt(String msg) throws Exception {
		Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
	      c.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(iv.getBytes()));
	      byte[] byteStr = Base64.decodeBase64(msg.getBytes());
	      return new String(c.doFinal(byteStr), "UTF-8");
	}
	

}

```
### CrpytServiceTest
``` java
package com.bit.boot09.service;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CryptServiceTest {
	String msg;
	@Autowired
	CryptService cryptService;

	@BeforeEach
	void setUp() throws Exception {
		msg = "abcd1234";
	}

	@Test
	void test() {
		System.out.println(cryptService.createMd5Encrypt(msg));
		System.out.println(cryptService.createSha256Encrypt(msg));
		System.out.println(cryptService.createSha512Encrypt(msg));
		
	}
	
	@Test
	void test02() throws Exception {
		String result1 = cryptService.createAESEncrypt(msg);
		System.out.println(result1);
		String result2 = cryptService.createAESDecrypt(result1);
		System.out.println(result2);
	}
	
	@Test
	void test03() {
		String result = cryptService.springEcrypt(msg);
		System.out.println(result);
		System.out.println(cryptService.isMatches(msg,result));
	}

}

```

# Token
세션 동기화문제 
## JWT
### 의존성 추가
``` xml
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>3.19.4</version>
</dependency>
```
### jwtService
``` java
package com.bit.boot09.service;

import org.springframework.stereotype.Service;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTCreationException;

@Service
public class JwtService {
	
	public String createHs256() {
		try {
		    Algorithm algorithm = Algorithm.HMAC256("secret");
		    String token = JWT.create()
		        .withIssuer("auth0")
		        .withClaim("deptno", 1234)
		        .sign(algorithm);
		    return token;
		} catch (JWTCreationException exception){
			return null;
		}
	}
}

```
